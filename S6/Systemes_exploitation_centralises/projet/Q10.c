#include <stdio.h>    /* entrées sorties */
#include <unistd.h>   /* primitives de base : fork, ...*/
#include <stdlib.h>   /* exit */
#include <sys/wait.h> /* wait */
#include <string.h> /* pour utiliser la commande strcmp */
#include <stdbool.h>
#include <string.h>
#include <stddef.h>
#include <errno.h>
#include <malloc.h>
#include <fcntl.h>
#define N 10

typedef struct cmdline cmdline;
const char* CMDINT[] = {"cd", "exit", "jobs", "stop", "bg", "fg"};

void suivi_fils (int sign);
void hdl_ctrlZ(int sign);
void hdl_ctrlC(int sign);
void initialiser_liste(Liste_Processus* l);
bool est_cmd_int(cmdline* cmd);
void traiter_cmdint(cmdline* cmd, Liste_Processus* l);
void executer_fils(cmdline* cmd, int fils, pid_t pidFils);

int changer_entree(char* fich);
int changer_sortie(char* fich);
void annuler_redir(int* desc_entree, int* desc_sortie, const int d_0, const int d_1);

int nb_tubes(cmdline* cmd);

Liste_Processus liste_p;
pid_t pid_avant_plan;

int main(int argc, char *argv[]) {
	
	initialiser_liste(&liste_p);
	
	int desc_entree = -1;
	int desc_sortie = -1;
	const int d_0 = dup(0);
	const int d_1 = dup(1);
	int err;

	struct sigaction nv_action;
	sigemptyset(&nv_action.sa_mask);
	nv_action.sa_flags = 0;
	nv_action.sa_handler = suivi_fils;
	sigaction(SIGCHLD, &nv_action, NULL);

	nv_action.sa_handler = hdl_ctrlZ;
	sigaction(SIGTSTP, &nv_action, NULL);

	nv_action.sa_handler = hdl_ctrlC;
	sigaction(SIGINT, &nv_action, NULL);
	
	while(1) {
		annuler_redir(&desc_entree, &desc_sortie, d_0, d_1);
		printf("shell$ ");
		cmdline* cmd;
		do {	
			cmd = readcmd();
		} while(cmd == NULL);

		if (cmd->err != NULL) {
			printf("erreur : %s", cmd->err);
		}

		if(*cmd->seq != NULL) {
			// traitement des redirections
			if (cmd->in != NULL) {
				desc_entree = changer_entree(cmd->in);
			}
			if (cmd->out != NULL) {
				desc_sortie = changer_sortie(cmd->out);
			}
			// traitement des commandes internes
			if (est_cmd_int(cmd)) {
				traiter_cmdint(cmd, &liste_p);
			// traitement autre
			} else {
				// initialiser les tubes -- QUESTION 10
				int nb = nb_tubes(cmd);
				int p[nb+1][2];
				for (int i = 0; i < nb; i++) {
					err = pipe(p[i]);
					if (err == -1) { perror("erreur pipes"); exit(6); }
				}

				// lancer les fils necessaires à l'execution -- QUESTION 10
				for (int fils = 0; fils < nb; fils++) {
					pid_t pidFils = fork();
					if (pidFils == -1) {
						perror("erreur fils"); 
						exit(1); 
					} else if (pidFils == 0) {

						// fermer les tubes non utilisés -- QUESTION 10
						err = close(p[fils][0]);
						if (err == -1) { perror("erreur close"); exit(7); }
						if (fils + 1 < nb) {
							err = close(p[fils+1][1]);
							if (err == -1) { perror("erreur close"); exit(7); }
						}
						for (int i = 0; i < nb; i++) {
							if ((i != fils) && (i != fils + 1)) {
								err = close(p[i][0]);
								if (err == -1) { perror("erreur close"); exit(7); }
								err = close(p[i][1]);
								if (err == -1) { perror("erreur close"); exit(7); }
							}
						}

						// faire les redirections -- QUESTION 10
						err = dup2(p[fils][1], 1);
						if (err == -1) { perror("erreur dup1"); exit(8); }
						if (fils + 1 < nb) { 
							err = dup2(p[fils + 1][0], 0);
							if (err == -1) { perror("erreur dup2"); exit(8); }
						}

						// fermer les tubes utilisés -- QUESTION 10
						err = close(p[fils][1]);
						if (err == -1) { perror("erreur close"); exit(7); }
						if (fils + 1 < nb) {
							err = close(p[fils+1][0]);
							if (err == -1) { perror("erreur close"); exit(7); }
						}
					}
					executer_fils(cmd, fils, pidFils);
				}
				
				// après l'execution, fermer les pipes ouverts s'il y en a -- QUESTION 10
				if (nb > 0) {
					for (int i = 1; i < nb; i++) {
						err = close(p[i][1]);
						if (err == -1) { perror("erreur close"); exit(7); }				
					}

					close(p[0][1]);
					desc_entree = p[0][0];
					err = dup2(p[0][0], 0);
					if (err == -1) { perror("erreur dup3"); exit(8); }
				}

				// execution de la dernière commande -- QUESTION 10
				pid_t pid = fork();
				executer_fils(cmd, nb, pid);

				for (int i = 1; i < nb; i++) {
					err = close(p[i][0]);
					if (err == -1) { perror("erreur close"); exit(7); }					
				}
			}
		}
	}
	printf("Fin \n");
	return EXIT_SUCCESS;
}

void suivi_fils (int sig) {
    int etat_fils, pid_fils;
    do {
        pid_fils = (int) waitpid(-1, &etat_fils, WNOHANG | WUNTRACED | WCONTINUED);
        if ((pid_fils == -1) && (errno != ECHILD)) {
            perror("waitpid");
            exit(EXIT_FAILURE);
        } else if (pid_fils > 0) {
            if (WIFSTOPPED(etat_fils)) {
		// changer l'etat dans la liste des processus en suspendu
			changer_etat(&liste_p, pid_fils, SUSPENDU);
			pid_avant_plan = 0;
		
            } else if (WIFCONTINUED(etat_fils)) {
		// changer l'etat dans la liste des processus en actif
			changer_etat(&liste_p, pid_fils, ACTIF);

            } else if (WIFEXITED(etat_fils)) {
		// supprimer de la liste des processus
			supprimer(&liste_p, pid_fils);
			pid_avant_plan = 0;

            } else if (WIFSIGNALED(etat_fils)) {
		// supprimer de la liste des processus
			supprimer(&liste_p, pid_fils);
			pid_avant_plan = 0;
            }
        }
    } while (pid_fils > 0);
}

// handler pour CTRL+Z
void hdl_ctrlZ(int sign) {
	if (pid_avant_plan > 0) {
		printf("Je suspends le fils en avant %d\n", pid_avant_plan);
		kill(pid_avant_plan, SIGSTOP);
	}
}

// handler pour CTRL+C
void hdl_ctrlC(int sign) {
	if (pid_avant_plan > 0) {
		printf("J'arrête le fils en avant %d\n", pid_avant_plan);
		kill(pid_avant_plan, SIGKILL);
	}
}

// initialiser la liste des processus 
void initialiser_liste(Liste_Processus* l) {
	l->capacite = N;
	l->taille = 0;
	l->l = malloc(N*sizeof(Processus));	
}

// vraie si la commande est une commande interne
bool est_cmd_int(cmdline* cmd) {
	bool res = false;
	for (int i=0; i < 6; i++) {
		if (strcmp(cmd->seq[0][0], CMDINT[i]) == 0) {
			res = true;
		}
	}
	return res;
}

// traiter une commande interne 
void traiter_cmdint(cmdline* cmd, Liste_Processus* l) {
	if (strcmp(cmd->seq[0][0], "cd") == 0) {
		chdir(cmd->seq[0][1]);
	}
	if (strcmp(cmd->seq[0][0], "exit") == 0) {
		exit(0);
	}
	if (strcmp(cmd->seq[0][0], "jobs") == 0) {
		jobs(l);
	}
	if (strcmp(cmd->seq[0][0], "stop") == 0) {
		int ident = atoi(cmd->seq[0][1]);
		if (est_ident(l, ident)) {
			stop(ident, l);
		} else { printf("mauvais identifiant\n"); }
	}
	if (strcmp(cmd->seq[0][0], "bg") == 0) {
		int ident = strtol(cmd->seq[0][1],NULL,0);
		if (est_ident(l, ident)) {
			bg(ident, l, &pid_avant_plan);
		} else { printf("mauvais identifiant\n"); }
	}
	if (strcmp(cmd->seq[0][0], "fg") == 0) {
		int ident = strtol(cmd->seq[0][1],NULL,0);
		if (est_ident(l, ident)) {
			fg(ident, l, &pid_avant_plan);
		} else { printf("mauvais identifiant\n"); }
	} else {
	}
}

// traier une commande non-interne 
void executer_fils(cmdline* cmd, int fils, pid_t pidFils) {

	if (pidFils < 0) {
		perror("erreur fork");
		exit(1);
	} else if (pidFils == 0) {
		
		signal(SIGINT, SIG_IGN);
		signal(SIGTSTP, SIG_IGN);

		int errExec = execvp(cmd->seq[fils][0], cmd->seq[fils]);
		if (errExec == -1) {
			perror("erreur execution");
			exit(2);
		}
	} else {
		// ajout du processus à la liste
		char* ligne_cmd;
		ligne_cmd = malloc(strlen(cmd->seq[fils][0])+1);
		strcpy(ligne_cmd, cmd->seq[fils][0]);
		Processus p = nv_processus(&liste_p, pidFils, ACTIF, ligne_cmd);
		ajouter(&liste_p, p);
		
		// commande en arriere plan
		if (cmd->backgrounded != NULL) {
			pid_avant_plan = 0;				
		}
		else {
			pid_avant_plan = pidFils;
		}

		// attente avant-plan 
		while (pid_avant_plan > 0) {
			pause();
		}
	}
}

// redirection de l'entree
int changer_entree(char* fich) {
	int desc = open(fich, O_RDONLY);
	if (desc == -1) {
		perror("erreur entree");
	}
	int err = dup2(desc, 0);
	if (err == -1) {
		perror("erreur dup entree");
		desc = -1;
	}
	return desc;
}

// redirection de la sortie 
int changer_sortie(char* fich) {
	int desc = open(fich, O_WRONLY|O_CREAT|O_TRUNC, 0640);
	if (desc == -1) {
		perror("erreur sortie");
	}
	int err = dup2(desc, 1);
	if (err == -1) {
		perror("erreur dup sortie");
		desc = -1;
	}
	return desc;
}

// remettre à 0 et 1 les entree et sortie 
void annuler_redir(int* desc_entree, int* desc_sortie, const int d_0, const int d_1) {
	if (*desc_entree != -1) {
		int err = dup2(d_0,0);
		if (err == -1) { perror("erreur dup 0"); }
		err = close(*desc_entree);
		if (err == -1) { perror("erreur close entree"); }
		*desc_entree = -1;
	}
	if (*desc_sortie != -1) {
		int err = dup2(d_1,1);
		if (err == -1) { perror("erreur dup 1"); }
		err = close(*desc_sortie);
		if (err == -1) { perror("erreur close sortie"); }
		*desc_sortie = -1;
	}
}

// obtenir le nombre de tubes necessaires à l'execution de la commande
int nb_tubes(cmdline* cmd) {
	int res = 0;
	while ((cmd->seq[res]) != NULL) {
		res++;
	}
	return res - 1;
}

